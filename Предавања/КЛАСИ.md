##### Објекти - работи што можат да се допрат, но и улоги, настани, интеракција, апстрактни или реални термини, дефинирани етитети во проблем

## Објект = податоци + методи/начини

 - секој објект има одговорност да знае и одговорност да работи.

- многу важен аспект на објектот е неговото однесување (или работите што тој може да ги изврши)

- однесувањето се иницира со испраќање на порака до објектот (со повикување на метод дефиниран за самиот објект)

„со методите стапува во интеракција со другите објекти“
„податоци = атрибути на објектот“
„методи = акции што може да ги превземе објектот“

## Класа дефинира множество на објекти што делат исти карактеристики однесување и релации

### Класите овозможуваат моделирање на објекти за една С++ програма?, а моделирајќи ги нивните:
- атрибути 
- однесувања
class {
	private: // иницијално се претпоставува дека сите членови на класата се од типот private
	public: 
};

*податочни членови на класата се декларираат во секцијата private: на класата и методите во секцијата public:*

**членовите означени како приватни се недостапни надвор од класата односно информацијата од оваа секција е затворена за сите надворешни „клиенти“ класата.**

---
```c++
class class_name {
Access_Control_label:
	членови;
	(податоци & методи)
Access_Control_label:
	членови;
	(податоци & методи)
};
```
---
 Синтакса на класа
```c++
class Krug {

private:
	int radius;
	-------------- int radius = 50 ------------- грешка
public:
	void set (int d);
	flaot presmetajPlostina();

};

void Krug::set(int d) {
	radius = d; // можеме да пристапиме бидејќи сме во рамки на класата
}

flaot Krug::presmetajPlostina() {
	return radius * radius * 3.14;
}
```
---
```c++
int main() {
	Krug k1; // k1  е објект од класата Krug
	k1.radius = 10; .... грешка во компајлер бидејќи не можеме да пристапиме во радиус бидејќи е приватен VIP ;)
	k1.postavi(10); // сега веќе нема да е грешка :D
	cout <<	k1.presmetajPlostina();
}
```
---
Не е можно податочните членови во класата да бидат иницијализирани при нивната декларација во класата.

Krug finki
poleKrugovi[5]
*pointerToKrug
&referenceToKrug = finki; // драги шпага

DRAGI SHPAGA

## иницијализација:

со сетер може
 ЛОЛ


драги шпага

конструктор автоматизиран сетер

### Конструктор се методи и се дел од самите класи (ама не класични)
- исто име како класата, не враќа вредност
---
```c++
class Krug {
private:
	int radius;
public:
	Krug () { // default конструктор
		radius = 0;
	}
	Krug (int r) { // конструктор со параметри
		if (r >= 0) 
			radius = r;
		else 
			radius = 0;
		}
	float presmetajPlostina();
};

int main() {
	Krug k1,k2(8);
}
```
---
// ако напишеме наш конструктор со параметри, ќе мора и експлицитно да го напишеме дефалтниот конструктор ако сакаме да го користиме (ако напишеме само конструктор со параметри тогаш ќе можеме само на тој начин на иницијализираме вредности)

---
```c++
Krug k2(10,2,3); // со една наредба даваме вредност на 3 атрибути (со сетери ќе беше долго)
```
---
- синтакса на конструктор ?
```c++
#include <iostream>
#include <iomanip>
using namespace std;

class Date {
	int y, m, d;
public:
	Date(int y = 1900, int m = 1, int d = 1); // isto kako defaulten
	void printUS() {
		cout << setw(2) << setfill('0') << m << '/';
		cout << setw(2) << setfill('0') << d << '/' << y << endl;
	}
	void printEU() {
		cout << setw(2) << setfill('0') << d << '.';
		cout << setw(2) << setfill('0') << m << '.' << y << endl;
	}
};

Date::Date(int yr, int mth, int day) {
	(...)
}

int main() {
	Date d(2000); // y = 2000, m = 1, d = 1. // ги испуштаме м и д
	Date d1 (2000, 2); // y = 2000, m = 2, d = 1 

}
```
---
### Деструктори
- извршуваат чистење за да се врати на системот меморијата резервирана за објектот
- името се формира со користење на оператор *tilde* (~) на кое следи името на класата
	- ~Date()
- единствен е, нема аргументи и не враќа вредност, се повикува автоматски за објект од класата кога тој излегува од опсегот и треба да се уништи. Експлицитен повик на деструктор не е препорачлив.
- Ако не се дефинира од страна на корисникот, компајлерот автоматски дефинира тривијален деструктор
- се уништува кога завршува програмата
---
```c++
int main() {
	Date d1;
	{
		(...)
		Date d2;
	}
	// тука ќе се уништи d2
}
```
---
- можеме и глобален објект
- static променлива веќе е алоцирана меморијата и толку
```c++
void func() {
	static Test statictest ("static"); // само еднаш ќе се направи променливата, по вторпат ако ја повикаме функцијата, оваа статик променлива нема да се направи уште еднаш (веќе е направена?)
	Test functest("func");
}

func();
{
	Test first("main inner"); // локален објект за овој блок
}
// кога ќе излеземе од овој блок ќе се уништи овој објект
```
---
